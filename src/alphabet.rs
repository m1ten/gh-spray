// Fonts sourced from https://github.com/Annihil/github-spray

#[derive(Clone)]
pub struct Font(Vec<(char, Vec<String>)>);

impl Font {
    pub fn new(name: &str) -> Self {
        let patterns = match name.to_ascii_lowercase().as_str() {
            "default" => create_default_patterns(),
            _ => {
                eprintln!("Warning: font '{}' not supported, using default", name);
                create_default_patterns()
            }
        };
        Font(patterns)
    }

    pub fn get_patterns(&self) -> &[(char, Vec<String>)] {
        &self.0
    }
}

fn create_default_patterns() -> Vec<(char, Vec<String>)> {
    let mut patterns = Vec::new();

    for case in [true, false] {
        for i in 0..26 {
            let ch = if case {
                (b'A' + i) as char
            } else {
                (b'a' + i) as char
            };
            let pattern = match ch.to_ascii_lowercase() {
                'a' => vec![
                    "00000", "11111", "10001", "11111", "10001", "10001", "00000",
                ],
                'b' => vec![
                    "00000", "11110", "10001", "11110", "10001", "11110", "00000",
                ],
                'c' => vec![
                    "00000", "11111", "10000", "10000", "10000", "11111", "00000",
                ],
                'd' => vec![
                    "00000", "11110", "10001", "10001", "10001", "11110", "00000",
                ],
                'e' => vec![
                    "00000", "11111", "10000", "11110", "10000", "11111", "00000",
                ],
                'f' => vec![
                    "00000", "11111", "10000", "11110", "10000", "10000", "00000",
                ],
                'g' => vec![
                    "00000", "11111", "10000", "10111", "10001", "11111", "00000",
                ],
                'h' => vec![
                    "00000", "10001", "10001", "11111", "10001", "10001", "00000",
                ],
                'i' => vec![
                    "00000", "11111", "00100", "00100", "00100", "11111", "00000",
                ],
                'j' => vec![
                    "00000", "11111", "00001", "00001", "10001", "01110", "00000",
                ],
                'k' => vec![
                    "00000", "10001", "10010", "11100", "10010", "10001", "00000",
                ],
                'l' => vec![
                    "00000", "10000", "10000", "10000", "10000", "11111", "00000",
                ],
                'm' => vec![
                    "00000", "10001", "11011", "10101", "10001", "10001", "00000",
                ],
                'n' => vec![
                    "00000", "10001", "11001", "10101", "10011", "10001", "00000",
                ],
                'o' => vec![
                    "00000", "01110", "10001", "10001", "10001", "01110", "00000",
                ],
                'p' => vec![
                    "00000", "11111", "10001", "11111", "10000", "10000", "00000",
                ],
                'q' => vec![
                    "00000", "11111", "10001", "10001", "10011", "11111", "00000",
                ],
                'r' => vec![
                    "00000", "11111", "10001", "11110", "10010", "10001", "00000",
                ],
                's' => vec![
                    "00000", "11111", "10000", "11111", "00001", "11111", "00000",
                ],
                't' => vec![
                    "00000", "11111", "00100", "00100", "00100", "00100", "00000",
                ],
                'u' => vec![
                    "00000", "10001", "10001", "10001", "10001", "11111", "00000",
                ],
                'v' => vec![
                    "00000", "10001", "10001", "10001", "01010", "00100", "00000",
                ],
                'w' => vec![
                    "00000", "10001", "10001", "10101", "11011", "10001", "00000",
                ],
                'x' => vec![
                    "00000", "10001", "01010", "00100", "01010", "10001", "00000",
                ],
                'y' => vec![
                    "00000", "10001", "01010", "00100", "00100", "00100", "00000",
                ],
                'z' => vec![
                    "00000", "11111", "00010", "00100", "01000", "11111", "00000",
                ],
                _ => unreachable!(),
            };

            let final_pattern = if !case {
                pattern
                    .iter()
                    .map(|row| {
                        if row.contains('1') {
                            row.replace("11111", "01110").replace("1111", "0111")
                        } else {
                            row.to_string()
                        }
                    })
                    .collect()
            } else {
                pattern.iter().map(|s| s.to_string()).collect()
            };

            patterns.push((ch, final_pattern));
        }
    }

    for i in 0..10 {
        let ch = (b'0' + i) as char;
        let pattern = match i {
            0 => vec![
                "00000", "01110", "10001", "10001", "10001", "01110", "00000",
            ],
            1 => vec!["00", "11", "01", "01", "01", "01", "00"],
            2 => vec![
                "00000", "01110", "10001", "00100", "01000", "11111", "00000",
            ],
            3 => vec![
                "00000", "11111", "00001", "01111", "00001", "11111", "00000",
            ],
            4 => vec![
                "00000", "10001", "10001", "11111", "00001", "00001", "00000",
            ],
            5 => vec![
                "00000", "11111", "10000", "11111", "00001", "11111", "00000",
            ],
            6 => vec![
                "00000", "01111", "10000", "11111", "10001", "01111", "00000",
            ],
            7 => vec![
                "00000", "11111", "00001", "00010", "00100", "01000", "00000",
            ],
            8 => vec![
                "00000", "01110", "10001", "01110", "10001", "01110", "00000",
            ],
            9 => vec![
                "00000", "01110", "10001", "01111", "00001", "01111", "00000",
            ],
            _ => vec![
                "00000", "11111", "00001", "11111", "10000", "11111", "00000",
            ],
        }
        .iter()
        .map(|s| s.to_string())
        .collect();
        patterns.push((ch, pattern));
    }

    // Add special characters
    let special_chars = vec![
        (
            '-',
            vec![
                "00000", "00000", "00000", "01110", "00000", "00000", "00000",
            ],
        ),
        (
            '_',
            vec![
                "00000", "00000", "00000", "00000", "00000", "11111", "00000",
            ],
        ),
        (
            '.',
            vec![
                "00000", "00000", "00000", "00000", "00000", "00100", "00000",
            ],
        ),
        (
            '/',
            vec![
                "00000", "00001", "00010", "00100", "01000", "10000", "00000",
            ],
        ),
        (
            '\\',
            vec![
                "00000", "10000", "01000", "00100", "00010", "00001", "00000",
            ],
        ),
        (')', vec!["000", "100", "010", "001", "010", "100", "000"]),
        ('(', vec!["000", "001", "010", "100", "010", "001", "000"]),
        (
            '[',
            vec!["0000", "0111", "0100", "0100", "0100", "0111", "0000"],
        ),
        (
            ']',
            vec!["0000", "1110", "0010", "0010", "0010", "1110", "0000"],
        ),
        (
            ':',
            vec![
                "00000", "00000", "00100", "00000", "00100", "00000", "00000",
            ],
        ),
        (
            '*',
            vec![
                "00000", "00000", "10101", "00100", "10101", "00000", "00000",
            ],
        ),
        (
            '!',
            vec![
                "00000", "00100", "00100", "00100", "00000", "00100", "00000",
            ],
        ),
        (
            ' ',
            vec![
                "00000", "00000", "00000", "00000", "00000", "00000", "00000",
            ],
        ),
    ];

    patterns.extend(
        special_chars
            .into_iter()
            .map(|(ch, arr)| (ch, arr.iter().map(|s| s.to_string()).collect())),
    );

    create_emoji_patterns().iter().for_each(|(ch, arr)| {
        patterns.push((*ch, arr.iter().map(|s| s.to_string()).collect()));
    });

    patterns
}

fn create_emoji_patterns() -> Vec<(char, Vec<String>)> {
    let patterns = vec![
        (
            '😀',
            vec![
                "00000", "01110", "10001", "11111", "10001", "01110", "00000",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
        ),
        (
            '😊',
            vec![
                "00000", "01110", "10101", "11111", "10001", "01110", "00000",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
        ),
        (
            '😎',
            vec![
                "00000", "11111", "10101", "11111", "10001", "01110", "00000",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
        ),
        (
            '❤',
            vec![
                "00000", "01010", "11111", "11111", "01110", "00100", "00000",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
        ),
        (
            '🚀',
            vec![
                "00100", "01110", "11111", "01110", "01010", "10001", "00000",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
        ),
        (
            '⭐',
            vec![
                "00100", "01110", "11111", "01110", "11111", "01010", "00000",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
        ),
    ];

    patterns
}

pub const WEEK_DAYS: usize = 7;
pub const CHARS: [char; 4] = ['░', '▒', '▓', '█'];
